# 11. 배열 렌더링하기

### 배열 렌더링 하기

다음과 같은 배열을 렌더링 한다고 하자.

```jsx
const users = [
        {
            id: 1,
            username: 'velopert',
            email: 'public.velopert@gmail.com'
        },
        {
            id: 2,
            username: 'tester',
            email: 'tester@example.com'
        },
        {
            id: 3,
            username: 'liz',
            email: 'liz@example.com'
        }
    ];
```

가장 비효율적인 방법은 각각의 인덱스에 대해서 다 작성하는 것이다.

```jsx
const UserList = () => {
    const users = [
        {
            id: 1,
            username: 'velopert',
            email: 'public.velopert@gmail.com'
        },
        {
            id: 2,
            username: 'tester',
            email: 'tester@example.com'
        },
        {
            id: 3,
            username: 'liz',
            email: 'liz@example.com'
        }
    ];
    return (
        <>
            <div><b>{users[0].username}</b>({users[0].email})</div>
						<div><b>{users[1].username}</b>({users[1].email})</div>
						<div><b>{users[2].username}</b>({users[2].email})</div>
        </>
    );
}
```

여기서 중복된 것이 있으므로 컴포넌트를 재사용할 수 있도록 새로 만들어 줄 수 있다.

```jsx
const User = ({user}) => {
		return (
				<div><b>{user.username}</b>({user.email})</div>
		);
}
const UserList = () => {
    const users = [
        {
            id: 1,
            username: 'velopert',
            email: 'public.velopert@gmail.com'
        },
        {
            id: 2,
            username: 'tester',
            email: 'tester@example.com'
        },
        {
            id: 3,
            username: 'liz',
            email: 'liz@example.com'
        }
    ];
    return (
        <>
            <User user={users[0]} />
						<User user={users[1]} />
						<User user={users[2]} />
        </>
    );
}
```

위 코드는 배열이 고정적이면 가능하겠지만 동적으로 할당될 경우 사용하기 힘든 방법이다.

그래서 여기서 사용할 방법은 `map` method를 사용하는 것이다. `map` 은 배열에 있는 각 원소를 변환하여 새로운 배열은 만들어주는 함수이다.

동적인 배열을 렌더링 해야 하는 경우에, 이 함수로 일반 데이터 배열을 리액트 엘리먼트로 이루어진 배열로 변환해주면 된다.

```jsx
import React from 'react';

const User = ({user}) => {
    const {username, email} = user;
    return (
        <div><b>{username}</b>({email})</div>
    );
}
const UserList = () => {
    const users = [
        {
            id: 1,
            username: 'velopert',
            email: 'public.velopert@gmail.com'
        },
        {
            id: 2,
            username: 'tester',
            email: 'tester@example.com'
        },
        {
            id: 3,
            username: 'liz',
            email: 'liz@example.com'
        }
    ];
    return (
        <>
            {users.map(user => (
                <User user={user} />
            ))}
        </>
    );
}
export default UserList;
```

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ee98fb21-9ee9-4c45-99fb-b5c9d73b8402/_2021-07-13__1.01.22.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ee98fb21-9ee9-4c45-99fb-b5c9d73b8402/_2021-07-13__1.01.22.png)

위 코드로 작성하면 렌더링은 정상적으로 된다. 하지만 콘솔창을 보면 위와 같은 경고문구가 하나 뜬다.

이 경고 문구는 리액트에서 배열을 렌더링 할 때 `key` 라는 props를 설정해주어야 한다는 의미이다.

이때 `key` 값은 각 배열이 고유한 값을 가질 수 있다록 해야 한다. 위 코드에서는 각 배열의 요소가 `id` 라는 고유한 값을 가지고 있으므로 설정해 보자.

```jsx
const UserList = () => {
    const users = [
        {
            id: 1,
            username: 'velopert',
            email: 'public.velopert@gmail.com'
        },
        {
            id: 2,
            username: 'tester',
            email: 'tester@example.com'
        },
        {
            id: 3,
            username: 'liz',
            email: 'liz@example.com'
        }
    ];
    return (
				// key 값에 고유한 값 id를 설정해 주었다.
        <>
            {users.map((user) => (
                <User user={user} key={user.id}/>
            ))}
        </>
    );
}
```

만약에 배열의 고유한 값이 없다면 `map` 의 콜백함수(callback)의 두번째 파라미터로 각 배열의 `index`를 넣어주면 된다.

```jsx
		return (
				// key 값에 각 배열 요소의 인덱스를 넣어주었다.
        <>
            {users.map((user, index) => (
                <User user={user} key={index}/>
            ))}
        </>
    );
```

### 질문

왜 map 함수로 배열을 랜더링할 때, key라는 props를 왜 설정해주어야 하는가?

- 배열에 항목을 추가하고 삭제할 때, 효율적으로 렌더링 하기 위해서이다.
- 키 값이 있으면, 그 항목만 찾아서 추가하거나 삭제할 수 있다.