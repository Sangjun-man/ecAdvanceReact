# 1-23

## Immer를 사용한 더 쉬운 불변성 관리

리액트에서 배열이나 객체를 업데이트 할 때 직접 수정 ❌

⇒ 불변성을 지켜주면서 업데이트를 해야한다.

- 잘못된 예시 (객체를 직접 수정한 경우)

```jsx
const object = {
  a: 1,
  b: 2
};

object.b = 3;
```

- 올바른 예시 (...연산자를 이용하여 새로운 객체를 만드는 경우)

```jsx
const object = {
  a: 1,
  b: 2
};

const nextObject = {
  ...object,
  b: 3
};
```

배열도 마찬가지로 `push`, `splice` 등의 함수를 사용하거나 n번째 항목 직접 수정 ❌

⇒ `concat`, `filter`, `map` 등의 함수 사용

```jsx
const todos = [
  {
    id: 1,
    text: '할 일 #1',
    done: true
  },
  {
    id: 2
    text: '할 일 #2',
    done: false
  }
];

const inserted = todos.concat({
  id: 3,
  text: '할 일 #3',
  done: false
});

const filtered = todos.filter(todo => todo.id !== 2);

const toggled = todos.map(
  todo => todo.id === 2
    ? {
      ...todo,
      done: !todo.done,
    }
    : todo
);
```

대부분의 경우 ...연산자 또는 배열 내장함수를 사용하는건 어렵지 않다.

→ 데이터의 구조가 까다로워질 경우 불변성을 지켜가면서 새로운 데이터를 생성해내는 코드가 복잡해짐.

→ 그렇다고 어려운건 아니지만 코드의 구조가 복잡해져서 코드를 봤을 때 한눈에 알아보기 힘듬.

⇒ 그래서 immer라는 라이브러리를 사용하면 보기 좋게 구현이 가능하다.

```jsx
const nextState = produce(state, draft => {
  const post = draft.posts.find(post => post.id === 1);
  post.comments.push({
    id: 3,
    text: '와 정말 쉽다!'
  });
});
```

자세한 사용법은 아래에서 설명한다.

코드의 상단에서 immer를 불러와주어야 한다. (보통 `produce` 라는 이름으로 불러온다).

```jsx
import produce from 'immer';
```

`produce` 함수를 사용할 때에는 첫번째 파라미터에는 수정하고 싶은 상태, 두번째 파라미터에는 어떻게 업데이트하고 싶을지 정의하는 함수를 넣어준다.

두번째 파라미터에 넣는 함수에서는 불변성에 대해 신경쓰지 않고 그냥 업데이트 해주면 다 알아서 해준다.      (...? 대박이네)

```jsx
const state = {
  number: 1,
  dontChangeMe: 2
};

const nextState = produce(state, draft => {
  draft.number += 1;
});

console.log(nextState);
// { number: 2, dontChangeMe: 2 }
```

하지만 Immer를 사용해서 간단해지는 업데이트도 있지만 코드가 길어지는 업데이트도 있다 ❗

- App.js(기존)

```jsx
function reducer(state, action) {
  switch (action.type) {
    case 'CREATE_USER':
      return {
        users: state.users.concat(action.user)
      };
    case 'TOGGLE_USER':
      return {
        ...state,
        users: state.users.map(user =>
          user.id === action.id ? { ...user, active: !user.active } : user
        )
      };
    case 'REMOVE_USER':
      return {
        ...state,
        users: state.users.filter(user => user.id !== action.id)
      };
    default:
      return state;
  }
}
```

- App.js(Immer 사용)

```jsx

function reducer(state, action) {
  switch (action.type) {
    case 'CREATE_USER':
      return produce(state, draft => {
        draft.users.push(action.user);
      });
    case 'TOGGLE_USER':
      return produce(state, draft => {
        const user = draft.users.find(user => user.id === action.id);
        user.active = !user.active;
      });
    case 'REMOVE_USER':
      return produce(state, draft => {
        const index = draft.users.findIndex(user => user.id === action.id);
        draft.users.splice(index, 1);
      });
    default:
      return state;
  }
}

```

`TOGGLE_USER` 액션의 경우엔 코드 깔끔하지만 나머지는 복잡

→ 사실 깔끔해졌는지 잘 모르겠다

### Immer와 함수형 업데이트

이전에 `useState`를 사용할 때 함수형 업데이트라는걸 할 수 있다고 배웠다.

```jsx
const [todo, setTodo] = useState({
  text: 'Hello',
  done: false
});

const onClick = useCallback(() => {
  setTodo(todo => ({
    ...todo,
    done: !todo.done
  }));
}, []);
```

`setTodo` 함수에 업데이트를 해주는 함수를 넣음으로써 `deps` 배열에 `todo` 를 넣지 않아도 된다.

`produce` 함수에 두개의 파라미터를 넣으면 첫번째 파라미터에 넣은 상태를 불변성을 유지하면서 새로운 상태를 만들어주지만, 첫번째 파라미터를 생략하고 바로 업데이트 함수를 넣어주면 반환값은 새로운 상태가 아닌 상태를 업데이트 해주는 함수가 된다.

```jsx
const todo = {
  text: 'Hello',
  done: false
};

const updater = produce(draft => {
  draft.done = !draft.done;
});

const nextTodo = updater(todo);

console.log(nextTodo);
// { text: 'Hello', done: true }
```

결국 `produce` 가 반환하는 것이 업데이트 함수가 되므로 `useState`의 업데이트 함수를 사용할 때 다음과 같이 구현 가능

```jsx
const [todo, setTodo] = useState({
  text: 'Hello',
  done: false
});

const onClick = useCallback(() => {
  setTodo(
    produce(draft => {
      draft.done = !draft.done;
    })
  );
}, []);
```

### 질문

- `produce` 함수에 첫번째 파라미터를 생략하고 업데이트 함수를 바로 넣어주면 반환되는 것은?

    새로운 상태가 아닌 상태를 업데이트 해주는 함수