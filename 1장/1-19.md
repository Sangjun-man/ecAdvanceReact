# 1-19

## React.memo 를 사용한 컴포넌트 리렌더링 방지

`React.momo` : 컴포넌트의 `props`가 바뀌지 않았다면, 리렌더링을 방지하여 컴포넌트의 리렌더링 성능 최적화를 해줄 수 있다.

CreateUser.js

```jsx
import React from 'react';

const CreateUser = ({ username, email, onChange, onCreate }) => {
  return (
    <div>
      <input
        name="username"
        placeholder="계정명"
        onChange={onChange}
        value={username}
      />
      <input
        name="email"
        placeholder="이메일"
        onChange={onChange}
        value={email}
      />
      <button onClick={onCreate}>등록</button>
    </div>
  );
};

export default React.memo(CreateUser);
```

UserList.js

```jsx
import React from 'react';

const User = React.memo(function User({ user, onRemove, onToggle }) {
  return (
    <div>
      <b
        style={{
          cursor: 'pointer',
          color: user.active ? 'green' : 'black'
        }}
        onClick={() => onToggle(user.id)}
      >
        {user.username}
      </b>
      &nbsp;
      <span>({user.email})</span>
      <button onClick={() => onRemove(user.id)}>삭제</button>
    </div>
  );
});

function UserList({ users, onRemove, onToggle }) {
  return (
    <div>
      {users.map(user => (
        <User
          user={user}
          key={user.id}
          onRemove={onRemove}
          onToggle={onToggle}
        />
      ))}
    </div>
  );
}

export default React.memo(UserList);
```

이렇게 React.memo로 감싸주면 input을 수정할 때 하단의 UserList가 리렌더링 되지 않는다.

❗그런데 User 중 하나라도 수정하면 모든 User들이 리렌더링 되고, CreateUser도 리렌더링 된다.

⇒ users 배열이 바뀔 때마다 `onCreate`, `onRemove`, `onToggle` 이 새로 만들어지기 때문이다.

    `deps` 에 `users` 가 들어가 있기 때문에 배열이 바뀔 때마다 함수들이 새로 만들어지는건 당연.

💡이것도 최적화하고싶다면?

`deps` 에서 `users` 를 지우고, 함수들에서 현재 `useState`로 관리하는 `users`를 참조하지 않게 하는 방법이 있다. ⇒ `useState` 의 함수형 업데이트를 통해 가능!

함수형 업데이트를 하게 되면 `setUsers` 에 등록하는 콜백함수의 파라미터에서 최신 `users` 를 참조 할 수 있기 때문에 `deps` 에 `users` 를 넣지 않아도 된다.

콜백 측에서는 `deps`안에 바뀐 state들이 들어있지 않아서 리렌더링을 진행하지 않는다.

onCreate 함수

```jsx
const onCreate = useCallback(() => {
    const user = {
      id: nextId.current,
      username,
      email
    };
    setUsers(users => users.concat(user));

    setInputs({
      username: '',
      email: ''
    });
    nextId.current += 1;
  }, [username, email]);
```

이렇게까지 해주면 최적화 끝!

- `useCallback`, `useMemo`, `React.memo` 는 컴포넌트의 성능을 실제로 개선할 수 있는 상황에서만 사용. (ex. `button` 에 `onClick` 으로 설정해준 함수들은 리렌더링을 막을 수 없다.)
- 렌더링 최적화 하지 않을 컴포넌트에 React.memo를 사용하는 것은 불필요한 추가행동이다.

- 배열이 바뀔때마다 함수가 새로 만들어지는 것을 최적화 하기 위한 방법은?

    함수형 업데이트를 통해 콜백함수의 파라미터에서 최신 users를 참조할 수 있기 때문에 deps에 users를 넣지 않아도 된다.