# 1-18

## useCallback을 사용하여 함수 재사용하기

`useMemo` 는 특정 결과값을 재사용 할 때 사용하는 반면, 

`useCallback` 은 특정 함수를 새로 만들지 않고 재사용하고 싶을 때 사용한다.

- `useCallback` 사용 X

```jsx
const onCreate = () => {
  const user = {
    id: nextId.current,
    username,
    email
  };
  setUsers(users.concat(user));

  setInputs({
    username: '',
    email: ''
  });
  nextId.current += 1;
};

const onRemove = id => {
  setUsers(users.filter(user => user.id !== id));
};
const onToggle = id => {
  setUsers(
    users.map(user =>
      user.id === id ? { ...user, active: !user.active } : user
    )
  );
};
```

이전에 만들었던 `onCreate`, `onRemove`, `onToggle` 함수들은 컴포넌트가 리렌더링 될 때 마다 새로 만들어진다. 함수를 선언하는 것 자체가 메모리나 CPU를 많이 차지하는 작업은 아니지만

한번 만든 함수를 필요할때만 새로 만들고 재사용하는 것은 중요하다

⇒  나중에 컴포넌트에서 `props` 가 바뀌지 않으면 Virtual DOM에 새로 렌더링하는 것조차 하지 않고 컴포넌트의 결과물을 재사용하는 최적화 작업을 할텐데 이 때 함수의 재사용이 필수!

- `useCallback` 사용 O

```jsx
const onCreate = useCallback(() => {
    const user = {
      id: nextId.current,
      username,
      email
    };
    setUsers(users.concat(user));

    setInputs({
      username: '',
      email: ''
    });
    nextId.current += 1;
  }, [users, username, email]);

  const onRemove = useCallback(
    id => {
      setUsers(users.filter(user => user.id !== id));
    },
    [users]
  );
  const onToggle = useCallback(
    id => {
      setUsers(
        users.map(user =>
          user.id === id ? { ...user, active: !user.active } : user
        )
      );
    },
    [users]
  );
```

❗ 함수 안에서 사용하는 상태 , `props` 가 있다면 꼭 `deps` 배열 안에 포함시켜야 한다.

그렇지 않으면 함수 내에서 해당 값들을 참조할 때 가장 최신의 값이라고 보장할 수 없다.

- uscCallback에서 deps안에 필요한 값에는 무엇이 있을까?

    함수 안에서 사용하는 props나 상태를 포함시켜야한다.